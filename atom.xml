<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鸦鸦的笔记本</title>
  
  <subtitle>想学会走路，必须先学会跑步</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lzx2005.github.io/"/>
  <updated>2019-10-08T07:21:40.002Z</updated>
  <id>https://lzx2005.github.io/</id>
  
  <author>
    <name>Raven</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高性能内存队列Disruptor初探</title>
    <link href="https://lzx2005.github.io/2019/10/08/%E9%AB%98%E6%80%A7%E8%83%BD%E5%86%85%E5%AD%98%E9%98%9F%E5%88%97Disruptor%E5%88%9D%E6%8E%A2/"/>
    <id>https://lzx2005.github.io/2019/10/08/高性能内存队列Disruptor初探/</id>
    <published>2019-10-08T07:12:57.000Z</published>
    <updated>2019-10-08T07:21:40.002Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这段时间在学习Disruptor的使用，由于其使用略微复杂，所以记录一下防止忘记：</p><h3 id="一定义数据结构">一、定义数据结构</h3><p>这个数据可以是任何你需要用到的数据，作为一个类封装起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二定义工厂类">二、定义工厂类</h3><p>工厂类负责提供事件对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lmax.disruptor.EventFactory;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderEventFactory</span> <span class="keyword">implements</span> <span class="title">EventFactory</span>&lt;<span class="title">OrderEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderEvent <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrderEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三定义消息handler">三、定义消息Handler</h3><p>消息handler负责处理从队列中弹出的消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lmax.disruptor.EventHandler;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderEventHandler</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">OrderEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(OrderEvent orderEvent, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"Handler : %d, %s, sequence: %d, endOfBatch: %b \n"</span>, orderEvent.getId(), orderEvent.getName(), sequence, endOfBatch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四创建disruptor对象">四、创建disruptor对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">OrderEventFactory orderEventFactory = <span class="keyword">new</span> OrderEventFactory(); <span class="comment">// 工厂对象</span></span><br><span class="line"><span class="keyword">int</span> ringBufferSize = <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// disruptor环大小</span></span><br><span class="line">ThreadFactory threadFactory = Executors.defaultThreadFactory(); <span class="comment">// 线程工厂，使用默认</span></span><br><span class="line">BlockingWaitStrategy blockingWaitStrategy = <span class="keyword">new</span> BlockingWaitStrategy(); <span class="comment">// 等待策略</span></span><br><span class="line">Disruptor&lt;OrderEvent&gt; orderEventDisruptor = <span class="keyword">new</span> Disruptor&lt;OrderEvent&gt;(</span><br><span class="line">  orderEventFactory,</span><br><span class="line">  ringBufferSize,</span><br><span class="line">  threadFactory,</span><br><span class="line">  ProducerType.SINGLE,</span><br><span class="line">  blockingWaitStrategy</span><br><span class="line">);</span><br><span class="line">OrderEventHandler orderEventHandler = <span class="keyword">new</span> OrderEventHandler(); <span class="comment">// 消息处理handler对象</span></span><br><span class="line">orderEventDisruptor.handleEventsWith(orderEventHandler); <span class="comment">// 绑定消息处理handler</span></span><br><span class="line">orderEventDisruptor.start(); <span class="comment">// 启动消息处理</span></span><br></pre></td></tr></table></figure><h3 id="五发送消息">五、发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RingBuffer&lt;OrderEvent&gt; ringBuffer = orderEventDisruptor.getRingBuffer(); <span class="comment">// 获取环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">100L</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">long</span> sequence = ringBuffer.next(); <span class="comment">// 得到坐标sequence</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    OrderEvent orderEvent = ringBuffer.get(sequence); <span class="comment">// 获得消息对象</span></span><br><span class="line">    orderEvent.setId(i); <span class="comment">// 填充消息对象参数</span></span><br><span class="line">    orderEvent.setName(<span class="string">"Event:"</span> + i); <span class="comment">// 填充消息对象参数</span></span><br><span class="line">    System.out.printf(<span class="string">"publish:%d\n"</span>, i);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ringBuffer.publish(sequence); <span class="comment">// 发布消息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六总结">六、总结</h3><p>通过以上几步即可发送消息，disruptor是一个性能非常高的内存队列，值得深入研究。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java" scheme="https://lzx2005.github.io/categories/Java/"/>
    
      <category term="中间件" scheme="https://lzx2005.github.io/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Java" scheme="https://lzx2005.github.io/tags/Java/"/>
    
      <category term="中间件" scheme="https://lzx2005.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>扩展Flink使其可以接收RocketMQ消息</title>
    <link href="https://lzx2005.github.io/2019/06/11/%E6%89%A9%E5%B1%95Flink%E4%BD%BF%E5%85%B6%E5%8F%AF%E4%BB%A5%E6%8E%A5%E6%94%B6RocketMQ%E6%B6%88%E6%81%AF/"/>
    <id>https://lzx2005.github.io/2019/06/11/扩展Flink使其可以接收RocketMQ消息/</id>
    <published>2019-06-11T08:58:22.000Z</published>
    <updated>2019-09-10T07:28:52.456Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从官方文档可以看到，Flink支持的数据源有如下几个：</p><ul><li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/dev/connectors/kafka.html" target="_blank" rel="noopener">Apache Kafka</a> (source/sink)</li><li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/dev/connectors/cassandra.html" target="_blank" rel="noopener">Apache Cassandra</a> (sink)</li><li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/dev/connectors/kinesis.html" target="_blank" rel="noopener">Amazon Kinesis Streams</a> (source/sink)</li><li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/dev/connectors/elasticsearch.html" target="_blank" rel="noopener">Elasticsearch</a> (sink)</li><li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/dev/connectors/filesystem_sink.html" target="_blank" rel="noopener">Hadoop FileSystem</a> (sink)</li><li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/dev/connectors/rabbitmq.html" target="_blank" rel="noopener">RabbitMQ</a> (source/sink)</li><li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/dev/connectors/nifi.html" target="_blank" rel="noopener">Apache NiFi</a> (source/sink)</li><li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/dev/connectors/twitter.html" target="_blank" rel="noopener">Twitter Streaming API</a> (source)</li></ul><p>对于其他的源，它也提供了接口给我们实现，扩展性非常好，今天我们就实现一个从RocketMQ取数据的实现。</p><p>打开项目，转到Flink处理类，可以看到：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FlinkKafkaConsumerDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="keyword">val</span> properties = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">    properties.setProperty(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>)</span><br><span class="line">    properties.setProperty(<span class="string">"group.id"</span>, <span class="string">"test"</span>)</span><br><span class="line">    <span class="keyword">val</span> data = env.addSource(<span class="keyword">new</span> <span class="type">FlinkKafkaConsumer</span>[<span class="type">String</span>](<span class="string">"lzxtest"</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), properties))</span><br><span class="line">    data.print()</span><br><span class="line">    env.execute(<span class="string">"FlinkKafkaConsumerDemo"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们按住Command，点击<code>FlinkKafkaConsumer</code>查看其结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlinkKafkaConsumer</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">FlinkKafkaConsumerBase</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FlinkKafkaConsumerBase</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">RichParallelSourceFunction</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">CheckpointListener</span>, <span class="title">ResultTypeQueryable</span>&lt;<span class="title">T</span>&gt;, <span class="title">CheckpointedFunction</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RichParallelSourceFunction</span>&lt;<span class="title">OUT</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRichFunction</span> <span class="keyword">implements</span> <span class="title">ParallelSourceFunction</span>&lt;<span class="title">OUT</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParallelSourceFunction</span>&lt;<span class="title">OUT</span>&gt; <span class="keyword">extends</span> <span class="title">SourceFunction</span>&lt;<span class="title">OUT</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SourceFunction</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceFunction.SourceContext&lt;T&gt; var1)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Public</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SourceContext</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">collect</span><span class="params">(T var1)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PublicEvolving</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">collectWithTimestamp</span><span class="params">(T var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PublicEvolving</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">emitWatermark</span><span class="params">(Watermark var1)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PublicEvolving</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">markAsTemporarilyIdle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Object <span class="title">getCheckpointLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，要实现自定义的Source，只需要实现接口<code>SourceFunction</code>即可，如果需要并行消费，可以实现<code>ParallelSourceFunction</code>。</p><p>创建类<code>RocketMQSourceFunction</code>，继承<code>SourceFunction</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketMQSourceFunction</span> <span class="keyword">implements</span> <span class="title">SourceFunction</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;String&gt; sourceContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// todo </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// todo </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们需要准备一个RocketMQ的消费者客户端，打开<code>pom.xml</code>，添加如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="comment">&lt;!-- 版本号注意修改 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于<code>RocketMQSourceFunction</code>来说，我们需要初始化一个Consumer，所以添加代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketMQSourceFunction</span> <span class="keyword">implements</span> <span class="title">SourceFunction</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"consumerGroupTest"</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当类在加载的时候，系统会创建一个consumer。对于一个Consumer来说，还需要知道我们要消费的nameSrvAddr和Topic是什么，所以我们添加字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketMQSourceFunction</span> <span class="keyword">implements</span> <span class="title">SourceFunction</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RocketMQSourceFunction</span><span class="params">(String nameSrvAddr, String topic)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nameSrvAddr = nameSrvAddr;</span><br><span class="line">    <span class="keyword">this</span>.topic = topic;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> String nameSrvAddr;</span><br><span class="line">  <span class="keyword">private</span> String topic;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写Run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;String&gt; sourceContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  consumer.setNamesrvAddr(nameSrvAddr);</span><br><span class="line">  consumer.subscribe(topic, <span class="string">"*"</span>);</span><br><span class="line">  consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -&gt; &#123;</span><br><span class="line">    msgs.forEach(msg -&gt; &#123;</span><br><span class="line">      sourceContext.collect(<span class="keyword">new</span> String(msg.getBody(), Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">  &#125;);</span><br><span class="line">  consumer.start();</span><br><span class="line">  System.out.println(<span class="string">"consumer started"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>consumer会在接收到消息时，发送消息到sourceContext中，这样Flink的流就可以接收到消息了。同时不要忘了重写cancal方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  consumer.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个完整的RocketMQ的数据源接收器我们已经实现好了，在需要用到的Flink代码中加入：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FlinkRocketMQConsumerDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="keyword">val</span> rmq = env.addSource(<span class="keyword">new</span> <span class="type">RocketMQSourceFunctionJava</span>(<span class="string">"localhost:9876"</span>, <span class="string">"lzxtest"</span>)).setParallelism(<span class="number">1</span>)</span><br><span class="line">    rmq.print().setParallelism(<span class="number">1</span>)</span><br><span class="line">    env.execute(<span class="string">"FlinkRocketMQConsumerDemo"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，Flink即可接收到RocketMQ的消息了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java" scheme="https://lzx2005.github.io/categories/Java/"/>
    
      <category term="中间件" scheme="https://lzx2005.github.io/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Java" scheme="https://lzx2005.github.io/tags/Java/"/>
    
      <category term="中间件" scheme="https://lzx2005.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="大数据" scheme="https://lzx2005.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Flink" scheme="https://lzx2005.github.io/tags/Flink/"/>
    
      <category term="RocketMQ" scheme="https://lzx2005.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>ThoughtWorks的面试题:Conference Track Management解题思路</title>
    <link href="https://lzx2005.github.io/2019/05/28/ThoughtWorks%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98-Conference-Track-Management%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/"/>
    <id>https://lzx2005.github.io/2019/05/28/ThoughtWorks的面试题-Conference-Track-Management解题思路/</id>
    <published>2019-05-28T09:33:53.000Z</published>
    <updated>2019-09-10T07:28:52.430Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="会议排期管理">会议排期管理</h1><h2 id="题目">题目</h2><p>最近看到一个ThoughtWorks的面试题，这边实现一下，问题如下：</p><p><strong>Problem Two: Conference Track Management</strong></p><p>You are planning a big programming conference and have received many proposals which have passed the initial screen process but you're having trouble fitting them into the time constraints of the day -- there are so many possibilities! So you write a program to do it for you.</p><ul><li>The conference has multiple tracks each of which has a morning and afternoon session.</li><li>Each session contains multiple talks.</li><li>Morning sessions begin at 9am and must finish before 12 noon, for lunch.</li><li>Afternoon sessions begin at 1pm and must finish in time for the networking event.</li><li>The networking event can start no earlier than 4:00 and no later than 5:00.</li><li>No talk title has numbers in it.</li><li>All talk lengths are either in minutes (not hours) or lightning (5 minutes).</li><li>Presenters will be very punctual; there needs to be no gap between sessions.</li></ul><p>Note that depending on how you choose to complete this problem, your solution may give a different ordering or combination of talks into tracks. This is acceptable; you don’t need to exactly duplicate the sample output given here.</p><p><strong>Test input:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Writing Fast Tests Against Enterprise Rails 60min</span><br><span class="line">Overdoing it in Python 45min</span><br><span class="line">Lua for the Masses 30min</span><br><span class="line">Ruby Errors from Mismatched Gem Versions 45min</span><br><span class="line">Common Ruby Errors 45min</span><br><span class="line">Rails for Python Developers lightning</span><br><span class="line">Communicating Over Distance 60min</span><br><span class="line">Accounting-Driven Development 45min</span><br><span class="line">Woah 30min</span><br><span class="line">Sit Down and Write 30min</span><br><span class="line">Pair Programming vs Noise 45min</span><br><span class="line">Rails Magic 60min</span><br><span class="line">Ruby on Rails: Why We Should Move On 60min</span><br><span class="line">Clojure Ate Scala (on my project) 45min</span><br><span class="line">Programming in the Boondocks of Seattle 30min</span><br><span class="line">Ruby vs. Clojure for Back-End Development 30min</span><br><span class="line">Ruby on Rails Legacy App Maintenance 60min</span><br><span class="line">A World Without HackerNews 30min</span><br><span class="line">User Interface CSS in Rails Apps 30min</span><br></pre></td></tr></table></figure><p><strong>Test output:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Track 1:</span><br><span class="line">09:00AM Writing Fast Tests Against Enterprise Rails 60min</span><br><span class="line">10:00AM Overdoing it in Python 45min</span><br><span class="line">10:45AM Lua for the Masses 30min</span><br><span class="line">11:15AM Ruby Errors from Mismatched Gem Versions 45min</span><br><span class="line">12:00PM Lunch</span><br><span class="line">01:00PM Ruby on Rails: Why We Should Move On 60min</span><br><span class="line">02:00PM Common Ruby Errors 45min</span><br><span class="line">02:45PM Pair Programming vs Noise 45min</span><br><span class="line">03:30PM Programming in the Boondocks of Seattle 30min</span><br><span class="line">04:00PM Ruby vs. Clojure for Back-End Development 30min</span><br><span class="line">04:30PM User Interface CSS in Rails Apps 30min</span><br><span class="line">05:00PM Networking Event</span><br><span class="line"></span><br><span class="line">Track 2:</span><br><span class="line">09:00AM Communicating Over Distance 60min</span><br><span class="line">10:00AM Rails Magic 60min</span><br><span class="line">11:00AM Woah 30min</span><br><span class="line">11:30AM Sit Down and Write 30min</span><br><span class="line">12:00PM Lunch</span><br><span class="line">01:00PM Accounting-Driven Development 45min</span><br><span class="line">01:45PM Clojure Ate Scala (on my project) 45min</span><br><span class="line">02:30PM A World Without HackerNews 30min</span><br><span class="line">03:00PM Ruby on Rails Legacy App Maintenance 60min</span><br><span class="line">04:00PM Rails for Python Developers lightning</span><br><span class="line">05:00PM Networking Event</span><br></pre></td></tr></table></figure><h2 id="代码介绍">代码介绍</h2><h3 id="实体类">实体类</h3><p>会议管理系统包含多个实体类</p><ul><li>Track : 负责记录每一天的行程，所有的排期，可以包含多个Track，也就是多天。</li><li>Session : 负责记录每一天上午，或者下午(可以扩展比如晚上)，记录了总共可以分配的时间，剩余可用的时间，开始时间(早上是9点，下午是1点)以及Talk列表。</li><li>Talk : 一次会议，包含的是会议标题，会议耗时。</li></ul><p><img src="/2019/05/28/ThoughtWorks的面试题-Conference-Track-Management解题思路/entities.png"></p><p>对于使用者来说，只需要进行一次<code>new Track()</code>操作，即可创建出一个包含<code>上午</code>和<code>下午</code>两个Session的Track，上午可用时间为180分钟，下午可用时间为240分钟，每一个Session生成了一个空的Talk List。</p><h3 id="枚举类">枚举类</h3><ul><li>SessionType : 定义一个Session，包括Session总共可分配时间以及Session开始时间，使用LocalTime定义时分秒。</li></ul><h3 id="总流程类">总流程类</h3><ul><li>TrackService : 处理传递过来的Talk列表，分配时间，安排会议，翻译一个Track列表。</li></ul><h3 id="工具类">工具类</h3><ul><li>FileUtils : 读取文件每一行，返回一个List&lt;String&gt;</li></ul><h2 id="调用流程">调用流程</h2><ol type="1"><li>读取文件：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = FileUtils.read(<span class="keyword">new</span> File(FileLaction.TEXT_FILE));</span><br><span class="line"><span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"file is null"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>生成Talk列表</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Talk&gt; talks = <span class="keyword">new</span> TreeSet&lt;&gt;(); <span class="comment">//使用TreeSet是可以让列表以时间排序</span></span><br><span class="line">list.forEach(title -&gt; &#123;</span><br><span class="line">    Talk talk = <span class="keyword">new</span> Talk(title);</span><br><span class="line">    talks.add(talk);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>调用Service</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TrackService trackService = TrackService.getInstance(); <span class="comment">//TrackService是单例的</span></span><br><span class="line">List&lt;Track&gt; tracks = trackService.manage(talks);</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>格式化输出</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tracks.size(); i++) &#123;</span><br><span class="line">    Track track = tracks.get(i);</span><br><span class="line">    System.out.println(<span class="string">"Track "</span> + (i + <span class="number">1</span>) + <span class="string">":"</span>);</span><br><span class="line">    System.out.print(track.getMorning().toString());</span><br><span class="line">    System.out.println(<span class="string">"12:00PM Lunch"</span>);</span><br><span class="line">    System.out.print(track.getAfternoon().toString());</span><br><span class="line">    System.out.println(<span class="string">"05:00PM Networking Event"</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>得到结果</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Track <span class="number">1</span>:</span><br><span class="line"><span class="number">09</span>:<span class="number">00</span>AM Communicating Over Distance <span class="number">60</span>min</span><br><span class="line"><span class="number">10</span>:<span class="number">00</span>AM Ruby on Rails: Why We Should Move On <span class="number">60</span>min</span><br><span class="line"><span class="number">11</span>:<span class="number">00</span>AM Writing Fast Tests Against Enterprise Rails <span class="number">60</span>min</span><br><span class="line"><span class="number">12</span>:<span class="number">00</span>PM Lunch</span><br><span class="line"><span class="number">01</span>:<span class="number">00</span>PM Rails Magic <span class="number">60</span>min</span><br><span class="line"><span class="number">02</span>:<span class="number">00</span>PM Ruby on Rails Legacy App Maintenance <span class="number">60</span>min</span><br><span class="line"><span class="number">03</span>:<span class="number">00</span>PM Overdoing it in Python <span class="number">45</span>min</span><br><span class="line"><span class="number">03</span>:<span class="number">45</span>PM Ruby Errors from Mismatched Gem Versions <span class="number">45</span>min</span><br><span class="line"><span class="number">04</span>:<span class="number">30</span>PM Programming in the Boondocks of Seattle <span class="number">30</span>min</span><br><span class="line"><span class="number">05</span>:<span class="number">00</span>PM Networking Event</span><br><span class="line"></span><br><span class="line">Track <span class="number">2</span>:</span><br><span class="line"><span class="number">09</span>:<span class="number">00</span>AM Accounting-Driven Development <span class="number">45</span>min</span><br><span class="line"><span class="number">09</span>:<span class="number">45</span>AM Pair Programming vs Noise <span class="number">45</span>min</span><br><span class="line"><span class="number">10</span>:<span class="number">30</span><span class="function">AM Clojure Ate <span class="title">Scala</span> <span class="params">(on my project)</span> 45min</span></span><br><span class="line"><span class="function">11:15AM Common Ruby Errors 45min</span></span><br><span class="line"><span class="function">12:00PM Lunch</span></span><br><span class="line"><span class="function">01:00PM Woah 30min</span></span><br><span class="line"><span class="function">01:30PM Ruby vs. Clojure <span class="keyword">for</span> Back-End Development 30min</span></span><br><span class="line"><span class="function">02:00PM Sit Down and Write 30min</span></span><br><span class="line"><span class="function">02:30PM Lua <span class="keyword">for</span> the Masses 30min</span></span><br><span class="line"><span class="function">03:00PM User Interface CSS in Rails Apps 30min</span></span><br><span class="line"><span class="function">03:30PM A World Without HackerNews 30min</span></span><br><span class="line"><span class="function">04:00PM Rails <span class="keyword">for</span> Python Developers lightning</span></span><br><span class="line"><span class="function">05:00PM Networking Event</span></span><br></pre></td></tr></table></figure><blockquote><p>我靠这份代码拿到了面试机会。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="面试" scheme="https://lzx2005.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://lzx2005.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="https://lzx2005.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ单机部署远程访问踩到的一个坑</title>
    <link href="https://lzx2005.github.io/2019/05/23/RocketMQ%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E8%B8%A9%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/"/>
    <id>https://lzx2005.github.io/2019/05/23/RocketMQ单机部署远程访问踩到的一个坑/</id>
    <published>2019-05-23T06:34:26.000Z</published>
    <updated>2019-09-10T07:28:52.430Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前根据<code>rocketmq.apache.org</code>的<code>get started</code>步骤部署的RocketMQ单节点，在远程访问的时候会出现如下问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Startorg.apache.rocketmq.remoting.exception.RemotingTooMuchRequestException: sendDefaultImpl call timeout</span><br><span class="line">at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.sendDefaultImpl(DefaultMQProducerImpl.java:<span class="number">612</span>)</span><br><span class="line">at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:<span class="number">1253</span>)</span><br><span class="line">at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:<span class="number">1203</span>)</span><br><span class="line">at org.apache.rocketmq.client.producer.DefaultMQProducer.send(DefaultMQProducer.java:<span class="number">214</span>)</span><br><span class="line">at com.cmit.fabric.java.rocketmq.RocketMQTest.producer.ProducerTest.producerStart(ProducerTest.java:<span class="number">39</span>)</span><br><span class="line">at com.cmit.fabric.java.rocketmq.RocketMQTest.producer.ProducerTest.main(ProducerTest.java:<span class="number">27</span>)</span><br></pre></td></tr></table></figure><p>在查询了相关资料以后，得到解决方案，假设我们的IP是：<code>172.16.10.53</code>，修改配置文件<code>broker.conf</code>，加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brokerIP1=172.16.10.53</span><br></pre></td></tr></table></figure><p>且需要在启动namesrv和broker的时候加上本机IP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqnamesrv -n 172.16.10.53:9876</span><br><span class="line">sh bin/mqbroker -n 172.16.10.53:9876 -c conf/broker.conf autoCreateTopicEnable=true</span><br></pre></td></tr></table></figure><p>启动后远程访问调用成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java" scheme="https://lzx2005.github.io/categories/Java/"/>
    
      <category term="中间件" scheme="https://lzx2005.github.io/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Java" scheme="https://lzx2005.github.io/tags/Java/"/>
    
      <category term="中间件" scheme="https://lzx2005.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>改造阿里巴巴otter框架，使其支持RocketMQ配置和输出（三）</title>
    <link href="https://lzx2005.github.io/2019/05/23/%E6%94%B9%E9%80%A0%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4otter%E6%A1%86%E6%9E%B6%EF%BC%8C%E4%BD%BF%E5%85%B6%E6%94%AF%E6%8C%81RocketMQ%E9%85%8D%E7%BD%AE%E5%92%8C%E8%BE%93%E5%87%BA%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://lzx2005.github.io/2019/05/23/改造阿里巴巴otter框架，使其支持RocketMQ配置和输出（三）/</id>
    <published>2019-05-23T02:46:10.000Z</published>
    <updated>2019-09-10T07:28:52.458Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>上一篇文章我们实现了RocketMQ的输出：</p><p>《改造阿里巴巴otter框架，使其支持RocketMQ配置和输出（二）》：<a href="/2019/05/20/改造阿里巴巴otter框架，使其支持RocketMQ配置和输出（二）/">快速链接</a></p><p>这篇我们将改造后的代码进行编译和部署，随后进行测试。</p><h1 id="打包">打包</h1><p>otter已经把打包的shell脚本写好了，查看目录<code>docker/build.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 省略不相关命令...</span></span><br><span class="line">else </span><br><span class="line">    rm -rf $BASE/node.*.tar.gz ; </span><br><span class="line">    rm -rf $BASE/manager.*.tar.gz ; </span><br><span class="line">    cd $BASE/../ &amp;&amp; mvn clean package -Dmaven.test.skip -Denv=release &amp;&amp; cd $current_path ;</span><br><span class="line">    cp $BASE/../target/node.deployer-*.tar.gz $BASE/</span><br><span class="line">    cp $BASE/../target/manager.deployer-*.tar.gz $BASE/</span><br><span class="line"><span class="meta">#</span><span class="bash">    docker build --no-cache -t canal/otter-all <span class="variable">$BASE</span>/</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>将<code>docker build</code> 的语句注释，执行<code>sh docker.sh</code>即可进行打包，打包完成后会在当前目录下生成manager和node两个tar.gz，我们将其远程传输到服务器中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp manager.deployer-4.2.18-SNAPSHOT.tar.gz root@ip:~/otter</span><br><span class="line">scp node.deployer-4.2.18-SNAPSHOT.tar.gz root@ip:~/otter</span><br></pre></td></tr></table></figure><h1 id="部署">部署</h1><p>进入部署服务器，使用tar解压：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd ~/otter</span><br><span class="line">mkdir manager</span><br><span class="line">mkdir node</span><br><span class="line">tar zxvf manager.deployer-4.2.18-SNAPSHOT.tar.gz -C manager</span><br><span class="line">tar zxvf node.deployer-4.2.18-SNAPSHOT.tar.gz -C node</span><br></pre></td></tr></table></figure><h2 id="导入数据库文件">导入数据库文件</h2><p>manager运行时需要依赖MySQL保存配置信息，根据文档<a href="https://github.com/alibaba/otter/wiki/Manager_Quickstart" target="_blank" rel="noopener">Manager_Quickstart</a>我们需要下载ddl文件进行数据库部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.github.com/alibaba/otter/master/manager/deployer/src/main/resources/sql/otter-manager-schema.sql </span><br><span class="line">mysql -h localhost -uroot -p</span><br></pre></td></tr></table></figure><p>执行DDL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; create database otter;</span><br><span class="line">mysql &gt; use otter;</span><br><span class="line">mysql &gt; source /root/otter/otter-manager-schema.sql;</span><br><span class="line">mysql &gt; exit;</span><br></pre></td></tr></table></figure><h2 id="部署manager">部署manager</h2><p>进入manager目录，修改<code>conf/otter.properties</code>文件，填写必须的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">## otter manager domain name</span><br><span class="line">otter.domainName = 127.0.0.1</span><br><span class="line">## otter manager http port</span><br><span class="line">otter.port = 8080</span><br><span class="line">## otter manager database config</span><br><span class="line">otter.database.driver.class.name = com.mysql.jdbc.Driver</span><br><span class="line">otter.database.driver.url = jdbc:mysql://127.0.0.1:3306/otter</span><br><span class="line">otter.database.driver.username = root</span><br><span class="line">otter.database.driver.password = root</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>保存后，执行部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh ./bin/startup.sh</span><br></pre></td></tr></table></figure><p>打开浏览器，输入<code>ip:8080</code>，查看是否可以看到otter管理后台：</p><p><img src="/2019/05/23/改造阿里巴巴otter框架，使其支持RocketMQ配置和输出（三）/1.png"></p><blockquote><p>日志可以在<code>manager/logs/manager.log</code>中查看，管理员默认的账号密码为<code>admin:admin</code>，记得修改密码，不然有安全隐患。</p></blockquote><h3 id="配置zookeeper">配置Zookeeper</h3><p>打开manager管理后台，以管理员账号登录，点击<code>机器管理</code>-<code>Zookeeper管理</code>，点击<code>添加</code>，输入集群信息，点击保存。这步必须执行，之后部署Node需要用到。</p><h2 id="部署node">部署Node</h2><p>打开manager管理后台，以管理员账号登录，点击<code>机器管理</code>-<code>Node管理</code>，点击<code>添加</code>，输入Node相关信息：</p><p><img src="/2019/05/23/改造阿里巴巴otter框架，使其支持RocketMQ配置和输出（三）/2.png"></p><p>点击保存，可以得到保存好的Node节点，且状态为未启动：</p><p><img src="/2019/05/23/改造阿里巴巴otter框架，使其支持RocketMQ配置和输出（三）/3.png"></p><p>复制<code>序号</code>列下的内容，图中为1。打开服务器后台，进入目录<code>node</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/otter/node</span><br><span class="line">echo 1 &gt; conf/nid</span><br></pre></td></tr></table></figure><p>这样就表示这个Node是为了上图这个Node而配置的，然后启动Node：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/startup.sh</span><br></pre></td></tr></table></figure><p>刷新后台，可以看到Node状态为<code>已启动</code></p><p><img src="/2019/05/23/改造阿里巴巴otter框架，使其支持RocketMQ配置和输出（三）/4.png"></p><p>到此为止，我们的Manager和Node已经部署完毕。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java" scheme="https://lzx2005.github.io/categories/Java/"/>
    
      <category term="中间件" scheme="https://lzx2005.github.io/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Java" scheme="https://lzx2005.github.io/tags/Java/"/>
    
      <category term="中间件" scheme="https://lzx2005.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>改造阿里巴巴otter框架，使其支持RocketMQ配置和输出（二）</title>
    <link href="https://lzx2005.github.io/2019/05/20/%E6%94%B9%E9%80%A0%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4otter%E6%A1%86%E6%9E%B6%EF%BC%8C%E4%BD%BF%E5%85%B6%E6%94%AF%E6%8C%81RocketMQ%E9%85%8D%E7%BD%AE%E5%92%8C%E8%BE%93%E5%87%BA%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://lzx2005.github.io/2019/05/20/改造阿里巴巴otter框架，使其支持RocketMQ配置和输出（二）/</id>
    <published>2019-05-20T07:38:36.000Z</published>
    <updated>2019-09-10T07:28:52.464Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>上篇文章我们分析了Otter的代码结构：</p><p>《改造阿里巴巴otter框架，使其支持RocketMQ配置和输出（一）》：<a href="/2019/05/15/改造阿里巴巴otter框架，使其支持RocketMQ配置和输出（一）/">快速链接</a></p><p>这篇我们开始正式进行改造。</p><h1 id="改造清单">改造清单</h1><ol type="1"><li>定义RocketMQ实体，定义一个RocketMQ的目标源。</li><li>改造管理系统的逻辑以及前端，支持RocketMQ的配置。</li><li>改造Transerformer模块，支持将数据转换成RocketMQ需要的格式。</li><li>改造Load模块，支持将数据向RocketMQ发送。</li></ol><p><img src="/2019/05/20/改造阿里巴巴otter框架，使其支持RocketMQ配置和输出（二）/3.png"></p><h1 id="定义rocketmq">定义RocketMQ</h1><p>otter 中定义一个数据源是由<code>DataMediaSource</code>决定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataMediaSource</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long              id;</span><br><span class="line">    <span class="keyword">private</span> String            name;</span><br><span class="line">    <span class="keyword">private</span> DataMediaType     type;</span><br><span class="line">    <span class="keyword">private</span> String            encode;</span><br><span class="line">    <span class="keyword">private</span> Date              gmtCreate;</span><br><span class="line">    <span class="keyword">private</span> Date              gmtModified;</span><br><span class="line">    <span class="comment">// get and set...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看这个表的继承类，可以看到<code>DbMediaSource</code>，定义了<code>url</code>、<code>username</code>、<code>password</code>、<code>driver</code>等连接数据库必须要的参数。于是我就照着他的实现方式来进行编写支持RocketMQ的新实现。</p><h2 id="rocketmqmediasource">RocketMQMediaSource</h2><p>编写类<code>RocketMQMediaSource</code>，定义连接到RocketMQ的必要参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketMqMediaSource</span> <span class="keyword">extends</span> <span class="title">DataMediaSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义连接到RocketMQ的gourpName</span></span><br><span class="line">    <span class="keyword">private</span> String            groupName;</span><br><span class="line">    <span class="comment">// 定义连接到RocketMQ的namesrvAddr</span></span><br><span class="line">    <span class="keyword">private</span> String            namesrvAddr;</span><br><span class="line">    <span class="comment">// get and set...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，在枚举类<code>DataMediaType</code>添加名称为<code>ROCKETMQ</code>的枚举。</p><h2 id="rocketmqdatamedia">RocketMQDataMedia</h2><p>实现DataMedia类<code>DataMedia&lt;Source extends DataMediaSource&gt;</code>，泛型定义为<code>RocketMQMediaSource</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketMqDataMedia</span> <span class="keyword">extends</span> <span class="title">DataMedia</span>&lt;<span class="title">RocketMQMediaSource</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>此类定义了一种数据媒介为RocketMQ。</p><h1 id="改造管理系统">改造管理系统</h1><h2 id="添加数据源页面">添加数据源页面</h2><p>打开<code>addDataSource.vm</code>可以看到添加数据源的前端代码，此代码是由<strong>模板引擎velocity</strong>编写的，Java会根据指定的格式渲染HTML页面展示给客户端。找到数据源下拉框Select，添加RocketMQ选项。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"sourceType"</span> <span class="attr">name</span>=<span class="string">"$dataMediaSourceGroup.type.key"</span> <span class="attr">onchange</span>=<span class="string">"changeform();"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"MYSQL"</span>&gt;</span>MySQL<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"ORACLE"</span>&gt;</span>Oracle<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"ROCKETMQ"</span>&gt;</span>RocketMQ<span class="tag">&lt;/<span class="name">option</span>&gt;</span>   <span class="comment">&lt;!--添加一行，提供RocketMQ的选择--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span>*<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于sourceType这个参数，后端可以识别为枚举类<code>DataMediaType.ROCKETMQ</code>，所以后端可以不需要修改其他的地方。</p><p>但是RocketMQ还需要填写额外的参数<code>gourpName</code>，我们需要对前端进行一定的改造，由于作者在这里预留了<code>changeFrom()</code>函数，触发条件为<code>select</code>下拉框被改变的时候，那么我们就可以判断当其改变时，作出相应的表单内容调整。</p><p>首先我们定义需要填写的groupName：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">id</span>=<span class="string">"group_name_tr"</span> <span class="attr">style</span>=<span class="string">"display: none;"</span>&gt;</span>  <span class="comment">&lt;!-- 注意第一行，很重要 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">th</span>&gt;</span>GroupName：<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"sourceGroupName"</span> <span class="attr">name</span>=<span class="string">"$dataMediaSourceGroup.groupName.key"</span> <span class="attr">value</span>=<span class="string">"$!dataMediaSourceGroup.groupName.value"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"setting_input"</span>/&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span>*<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span>#addDataSourceMessage ($dataMediaSourceGroup.groupName)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重写<code>changeForm()</code>函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeform</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"changed form"</span>)</span><br><span class="line">    <span class="comment">//获取 sourceType 的Dom对象</span></span><br><span class="line">    <span class="keyword">var</span> sourceType = <span class="built_in">document</span>.getElementById(<span class="string">'sourceType'</span>).value;</span><br><span class="line">    <span class="comment">//获取 groupName 的Dom对象</span></span><br><span class="line">    <span class="keyword">var</span> group_name_tr = <span class="built_in">document</span>.getElementById(<span class="string">"group_name_tr"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"ROCKETMQ"</span> === sourceType) &#123;</span><br><span class="line">        <span class="comment">// 如果是RocketMQ，则显示 groupName 的填写框</span></span><br><span class="line">        group_name_tr.style.display = <span class="string">"table-row"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则不显示</span></span><br><span class="line">        group_name_tr.style.display = <span class="string">"none"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以根据下拉框自动展示需要填写的表单了：</p><p><img src="/2019/05/20/改造阿里巴巴otter框架，使其支持RocketMQ配置和输出（二）/1.gif"></p><h2 id="验证连接数据源改造">验证连接数据源改造</h2><p>同时，需要将验证连接数据源，这个按钮所请求的后端逻辑进行改造，否则无法通过提交：</p><p><img src="/2019/05/20/改造阿里巴巴otter框架，使其支持RocketMQ配置和输出（二）/2.png"></p><p>根据DEBUG我们得知，该验证逻辑定义在<code>DataSourceChecker</code>类的check()方法中，所以我们对该方法进行改造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">check</span><span class="params">(String url, String username, String password, String encode, String sourceType, String groupName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"MYSQL"</span>.equalsIgnoreCase(sourceType) || <span class="string">"ORACLE"</span>.equalsIgnoreCase(sourceType)) &#123;</span><br><span class="line">    <span class="keyword">return</span> checkDB(url, username, password, encode, sourceType);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"RocketMQ"</span>.equalsIgnoreCase(sourceType)) &#123;</span><br><span class="line">    <span class="keyword">return</span> checkMQ(url, username, password, encode, sourceType, groupName);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> DATABASE_SUCCESS;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造后，系统可以根据入参sourceType执行不同的验证逻辑。对于RocketMQ的验证逻辑目前我只是将连接打开再关闭，如果没有报错则返回成功，但是目前看下来，好像这个逻辑并不严谨，希望讨论获得更好的方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">checkMQ</span><span class="params">(String url, String username, String password, String encode, String sourceType, String groupName)</span> </span>&#123;</span><br><span class="line">  DefaultMQProducer defaultMQProducer =<span class="keyword">new</span> DefaultMQProducerImpl(groupName);</span><br><span class="line">  defaultMQProducer.setNamesrvAddr(url);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    defaultMQProducer.start();</span><br><span class="line">    <span class="keyword">return</span> DATABASE_SUCCESS;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">    logger.error(<span class="string">"connect to RocketMQ failed"</span>, e);</span><br><span class="line">    <span class="keyword">return</span> DATABASE_FAIL;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    defaultMQProducer.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现rocketmqtransformer">实现RocketMQTransformer</h1><p>Otter对从Canal拉取到的数据进行了四步处理，分别是：Select、Extract、Transform、Load。</p><p>对于新的输出来说，只需要改造Transformer和Load即可。</p><p>查看源代码，找到node模块下的包<code>com.alibaba.otter.node.etl.transform</code>，可以看到基于MySQL和Oracle的实现：</p><p><img src="/2019/05/20/改造阿里巴巴otter框架，使其支持RocketMQ配置和输出（二）/4.png"></p><p>该实现继承自类<code>com.alibaba.otter.node.etl.transform.transformer.OtterTransformer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OtterTransformer</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">S <span class="title">transform</span><span class="params">(T data, OtterTransformerContext context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们只需要实现该接口即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketMQTransformer</span> <span class="keyword">implements</span> <span class="title">OtterTransformer</span>&lt;<span class="title">EventData</span>, <span class="title">EventData</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventData <span class="title">transform</span><span class="params">(EventData data, OtterTransformerContext context)</span> </span>&#123;</span><br><span class="line">        List&lt;CanalEntry.Column&gt; beforeColumns = data.getBeforeColumns();</span><br><span class="line">        List&lt;CanalEntry.Column&gt; afterColumns = data.getAfterColumns();</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, Object&gt; before = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        HashMap&lt;String, Object&gt; after = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (CanalEntry.Column column : beforeColumns) &#123;</span><br><span class="line">            before.put(column.getName(), column.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (CanalEntry.Column column : afterColumns) &#123;</span><br><span class="line">            after.put(column.getName(), column.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data.setAfter(after);</span><br><span class="line">        data.setBefore(before);</span><br><span class="line">        data.setAfterColumns(<span class="keyword">null</span>);</span><br><span class="line">        data.setBeforeColumns(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (data.getKeys().size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            data.setPrimaryKey(data.getKeys().get(<span class="number">0</span>).getColumnValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RocketMQTransformer</code>是<code>OtterTransformer</code>的RocketMQ版本实现，主要是根据使用方的需求进行数据的整理封装，返回合理的数据。这里我们将每个字段的改变前和改变后作为值存入数据集。</p><h1 id="实现rocketmqloader">实现RocketMQLoader</h1><p>实现Loader也是相同的，找到Loader接口<code>com.alibaba.otter.node.etl.load.loader.OtterLoader</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OtterLoader</span>&lt;<span class="title">P</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">load</span><span class="params">(P data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketMQLoader</span> <span class="keyword">implements</span> <span class="title">OtterLoader</span>&lt;<span class="title">DbBatch</span>, <span class="title">List</span>&lt;<span class="title">LoadContext</span>&gt;&gt;, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BeanFactory         beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;LoadContext&gt; <span class="title">load</span><span class="params">(DbBatch data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 发送MQ方法省略</span></span><br><span class="line">        <span class="keyword">return</span> sendToRocketMQ(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于篇幅限制，我省略了一些实现，包括管道配置、RocketMQClient工具类编写。</p><p>更多代码请参考我Fork出来的github项目：<a href="https://github.com/lzx2005/otter" target="_blank" rel="noopener">https://github.com/lzx2005/otter</a>，我修改的代码在分支<code>mq-extend-try-1</code>中。</p><p>接下来的第三篇文章就是对我们新改造的模块进行各方面的压测，确保其可以继承Otter优秀的性能，同时也能完美做到组件扩展。</p><p>未完待续。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java" scheme="https://lzx2005.github.io/categories/Java/"/>
    
      <category term="中间件" scheme="https://lzx2005.github.io/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Java" scheme="https://lzx2005.github.io/tags/Java/"/>
    
      <category term="中间件" scheme="https://lzx2005.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>慕课网Spark大数据课程笔记-Hadoop2.6.0环境搭建</title>
    <link href="https://lzx2005.github.io/2019/05/15/%E6%85%95%E8%AF%BE%E7%BD%91Spark%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-Hadoop2-6-0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://lzx2005.github.io/2019/05/15/慕课网Spark大数据课程笔记-Hadoop2-6-0环境搭建/</id>
    <published>2019-05-15T11:41:13.000Z</published>
    <updated>2019-09-10T07:28:52.455Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="系统准备">系统准备</h3><p>新建文件： /home/hadoop</p><ul><li>software ：存放软件安装包</li><li>app : 存放软件目录</li><li>data ： 存放测试数据</li><li>source ： 存放软件源码：spark</li></ul><h3 id="下载hadoop">下载Hadoop</h3><p>下载地址：http://archive.cloudera.com/cdh5/cdh/5/</p><p>下载版本：2.6.0-cdh5.7.0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://archive.cloudera.com/cdh5/cdh/5/hadoop-2.6.0-cdh5.7.0.tar.gz</span><br></pre></td></tr></table></figure><h3 id="配置环境和hadoop">配置环境和Hadoop</h3><p>去官网 hadoop.apache.org 查看安装手册</p><ol type="1"><li>安装JDK</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=[jdk]</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>机器参数设置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network</span><br><span class="line"></span><br><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=hadoop001</span><br><span class="line"></span><br><span class="line">vim /etc/hosts</span><br><span class="line"></span><br><span class="line">127.0.0.1 localhost</span><br><span class="line">[ip] hadoop001</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>SSH免密码登录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line">cp /root/.ssh/id_rsa.pub ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>修改hadoop-env.sh</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /root/hadoop/app/hadoop-2.6.0-cdh5.7.0/etc/hadoop</span><br><span class="line">vim hadoop-env.sh</span><br><span class="line"></span><br><span class="line">修改</span><br><span class="line">export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>修改core-site.xml</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /root/hadoop/app/hadoop-2.6.0-cdh5.7.0/etc/hadoop</span><br><span class="line">vim core-site.xml</span><br></pre></td></tr></table></figure><p>添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop001:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/hadoop/temp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="6" type="1"><li>修改hdfs-site.xml</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /root/hadoop/app/hadoop-2.6.0-cdh5.7.0/etc/hadoop</span><br><span class="line">vim hdfs-site.xml</span><br></pre></td></tr></table></figure><p>添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="启动hadoop">启动Hadoop</h3><ol type="1"><li>第一次启动：格式化HDFS</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hdfs namenode -format</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>启动HDFS</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-dfs.sh</span><br></pre></td></tr></table></figure><h3 id="验证hadoop">验证Hadoop</h3><p>在浏览器中输入IP:50070，如果能访问到Hadoop后端，则启动成功：</p><p><img src="/2019/05/15/慕课网Spark大数据课程笔记-Hadoop2-6-0环境搭建/1.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://lzx2005.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="慕课网Spark大数据课程" scheme="https://lzx2005.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%85%95%E8%AF%BE%E7%BD%91Spark%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AF%BE%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://lzx2005.github.io/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://lzx2005.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="大数据" scheme="https://lzx2005.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="https://lzx2005.github.io/tags/Spark/"/>
    
      <category term="Hadoop" scheme="https://lzx2005.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>改造阿里巴巴otter框架，使其支持RocketMQ配置和输出（一）</title>
    <link href="https://lzx2005.github.io/2019/05/15/%E6%94%B9%E9%80%A0%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4otter%E6%A1%86%E6%9E%B6%EF%BC%8C%E4%BD%BF%E5%85%B6%E6%94%AF%E6%8C%81RocketMQ%E9%85%8D%E7%BD%AE%E5%92%8C%E8%BE%93%E5%87%BA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://lzx2005.github.io/2019/05/15/改造阿里巴巴otter框架，使其支持RocketMQ配置和输出（一）/</id>
    <published>2019-05-15T02:27:49.000Z</published>
    <updated>2019-09-10T07:28:52.457Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近接到了一个需求，需要同步业务数据库至MQ，再进行相应的操作。</p><p>对于这种需求，其实阿里巴巴出品的canal（https://github.com/alibaba/canal）就可以做到，但是领导提出了更变态的需求，需要有前端界面，可以动态配置，读取什么表，发送到哪个MQ，哪个topic，哪个tag，还得需要有监控界面，查看每个时间段同步的数据，对于这种可配置的需求，阿里巴巴otter（https://github.com/alibaba/otter）可以完美做到，可是otter内置的canal阉割了发送到kafka和RocketMQ的功能。再三调研和判断后，我们还是决定对otter进行改造，将阉割了的发送MQ功能，给它装回去。</p><p>对我来说，我只有使用otter的经验，对于其源码还是有点生疏，所以我就在自己的博客开了一个新坑，记录一下我改造otter的过程。如果有不好的地方，欢迎砸我回复。</p><h2 id="熟悉源码">熟悉源码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/alibaba/otter.git</span><br><span class="line"><span class="built_in">cd</span> otter</span><br></pre></td></tr></table></figure><p>下载源码后，我们使用Idea打开项目，引入Maven包，可以看到目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">otter</span><br><span class="line">|--manager</span><br><span class="line">    |--biz</span><br><span class="line">    |--deployer</span><br><span class="line">    |--web</span><br><span class="line">|--node</span><br><span class="line">    |--canal</span><br><span class="line">    |--common</span><br><span class="line">    |--deployer</span><br><span class="line">    |--etl</span><br><span class="line">    |--extend</span><br><span class="line">|--shared</span><br><span class="line">    |--arbitrate</span><br><span class="line">    |--common</span><br><span class="line">    |--communication</span><br><span class="line">    |--etl</span><br><span class="line">    |--push</span><br></pre></td></tr></table></figure><h3 id="manager">Manager</h3><p>manager是对node节点进行管理，数据统计，node节点之间的协调，基本信息的同步等。</p><ul><li>biz：业务处理内容</li><li>deployer：manager打包和启动的类，主要内置一个jetty的服务启动器，通过OtterManagerLauncher启动</li><li>web：manager的web页面相关内容，包括接口</li></ul><h3 id="node">Node</h3><p>node是实际上进行数据同步的工程</p><ul><li>canal：canal客户端，就是订阅binlog的客户端，Otter采用的是Embed的方式引入Canal</li><li>common：公共内容定义</li><li>deployer：打包工具，运行脚本，内置jetty服务器，启动类OtterLauncher</li><li>etl：S.E.T.L 调度、处理的实现，是Otter最复杂、也是最核心的部分</li><li>extend：留有的扩展类，可以自定义一些处理过程</li></ul><h3 id="shared">Shared</h3><p>shared是manager和node公有的子系统</p><ul><li>arbitrate：仲裁器相关内容，代码比较多，后面我们慢慢分析</li><li>common：manager和node用到的一些公共类</li><li>communication：远程调用相关内容</li><li>etl</li><li>push</li></ul><blockquote><p>以上部分来自博文：https://www.cnblogs.com/f-zhao/p/8328987.html</p></blockquote><h2 id="改造方案">改造方案</h2><p>根据otter的github主页图，可以很清晰的了解otter的运行模式和结构。</p><p><img src="/2019/05/15/改造阿里巴巴otter框架，使其支持RocketMQ配置和输出（一）/1.jpeg"></p><p>阅读了官方文档：<a href="https://github.com/alibaba/otter/wiki/Otter扩展性" target="_blank" rel="noopener">https://github.com/alibaba/otter/wiki/Otter扩展性</a>，我们对otter的扩展性有了一定了解</p><p>为了增加MQ的功能，主要还是要对T（transformer）和L（load）进行改造</p><p>同时需要对manager进行二次开发，以满足配置MQ的需求。</p><p>所以改造的功能图如下所示：</p><p><img src="/2019/05/15/改造阿里巴巴otter框架，使其支持RocketMQ配置和输出（一）/2.png"></p><p>接下来就是对Manager进行改造了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java" scheme="https://lzx2005.github.io/categories/Java/"/>
    
      <category term="中间件" scheme="https://lzx2005.github.io/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Java" scheme="https://lzx2005.github.io/tags/Java/"/>
    
      <category term="中间件" scheme="https://lzx2005.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>填充每个节点的下一个右侧节点指针2</title>
    <link href="https://lzx2005.github.io/2019/04/09/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%882/"/>
    <id>https://lzx2005.github.io/2019/04/09/填充每个节点的下一个右侧节点指针2/</id>
    <published>2019-04-09T01:39:17.000Z</published>
    <updated>2019-09-10T07:28:52.434Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目">题目</h2><p>https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/</p><p>给定一个二叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><figure><img src="/2019/04/09/填充每个节点的下一个右侧节点指针2/p.png" alt=""><figcaption>sss</figcaption></figure><h2 id="思路">思路</h2><h3 id="solution">Solution</h3><p>二叉树层序遍历，以上图为例：</p><p>新建一个Queue，使用<code>层序遍历</code>二叉树的方式，将数据写入队列中。 队列我们使用<code>LinkedList&lt;Node&gt;</code>，并将root直接写入队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">queue.add(root);</span><br></pre></td></tr></table></figure><p>使用表的形式表示队列：</p><table><thead><tr class="header"><th style="text-align: center;">index</th><th style="text-align: center;">0</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th><th style="text-align: center;">6</th><th style="text-align: center;">7</th><th style="text-align: center;">8</th><th style="text-align: center;">9</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Node</td><td style="text-align: center;">1</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p>嵌套第一个循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// 二叉树层序遍历，每次遍历都会添加每一行新的数据，所以除非遍历完，否则不会空。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个循环内第一步要做的事情是获取队列<code>queue</code>的<code>size</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = queue.size(); <span class="comment">//获取当前队列中已有的节点的数量</span></span><br></pre></td></tr></table></figure><p>进入第二层循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = queue.size();</span><br><span class="line">    <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 大的循环每一次都是一层，每一层，我们循环将节点的Next指向下一个节点</span></span><br><span class="line">        Node node = queue.remove();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.next = queue.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第一次循环">第一次循环</h3><ol type="1"><li>得到size = 1</li><li>size = 1 &gt; 0 进入循环，size 变为0</li><li>Node node= queue.remove(); 得到当前队列中的节点 <code>node</code></li><li>判断当前size 不大于0 ，则不进行<code>node.next</code>指向操作</li><li>将<code>node</code>不为空的左节点存入队列，将不为空的右节点存入队列</li></ol><p>则当前队列内容为：</p><table><thead><tr class="header"><th style="text-align: center;">index</th><th style="text-align: center;">0</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th><th style="text-align: center;">6</th><th style="text-align: center;">7</th><th style="text-align: center;">8</th><th style="text-align: center;">9</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Node</td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><h3 id="第二次循环">第二次循环</h3><ol type="1"><li>得到size = 2</li><li>size = 2 &gt; 0 进入循环，size 变为1</li><li>Node node= queue.remove(); 得到当前队列中的节点 <code>node</code>， 因为弹出了第一个节点，当前队列为：</li></ol><table><thead><tr class="header"><th style="text-align: center;">index</th><th style="text-align: center;">0</th><th style="text-align: center;">1</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Node</td><td style="text-align: center;">3</td><td style="text-align: center;"></td></tr></tbody></table><ol start="4" type="1"><li>判断当前size 大于0 ，则进行<code>node.next</code>指向操作 node.next = queue.peek() ，那么2 就 指向了 3，但是3没有弹出。</li><li>将<code>node</code>不为空的左节点存入队列，将不为空的右节点存入队列，则当前队列为：</li></ol><table><thead><tr class="header"><th style="text-align: center;">index</th><th style="text-align: center;">0</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Node</td><td style="text-align: center;">3</td><td style="text-align: center;">4</td><td style="text-align: center;">5</td></tr></tbody></table><ol start="6" type="1"><li>继续循环，size = 1 &gt; 0 ,进入二层循环，size 变为0</li><li>Node node= queue.remove(); 得到当前队列中的节点 <code>node</code></li></ol><table><thead><tr class="header"><th style="text-align: center;">index</th><th style="text-align: center;">0</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Node</td><td style="text-align: center;">4</td><td style="text-align: center;">5</td><td style="text-align: center;"></td></tr></tbody></table><ol start="8" type="1"><li>判断当前size 不大于0 ，则不进行<code>node.next</code>指向操作，所以 3 指向的是<code>Null</code></li><li>将3的左右孩子存入队列：</li></ol><table><thead><tr class="header"><th style="text-align: center;">index</th><th style="text-align: center;">0</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Node</td><td style="text-align: center;">4</td><td style="text-align: center;">5</td><td style="text-align: center;">7</td></tr></tbody></table><ol start="10" type="1"><li>内层循环结束，开始新的一轮循环，直到所有的节点都指向正确的Next节点。</li></ol><h2 id="代码">代码</h2><p>代码仓库：</p><p>https://github.com/lzx2005/leetcode-solution/blob/master/0117-populating-next-right-pointers-in-each-node-ii/PopulatingNextRightPointersInEachNodeIi.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node node = queue.remove();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                node.next = queue.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="https://lzx2005.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="https://lzx2005.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    
      <category term="Java" scheme="https://lzx2005.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://lzx2005.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="https://lzx2005.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>如何设计一个短链接网站</title>
    <link href="https://lzx2005.github.io/2019/01/03/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%9F%AD%E9%93%BE%E6%8E%A5%E7%BD%91%E7%AB%99/"/>
    <id>https://lzx2005.github.io/2019/01/03/如何设计一个短链接网站/</id>
    <published>2019-01-03T01:41:51.000Z</published>
    <updated>2019-09-10T07:28:52.435Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在日常生活中，我们经常需要用到短链接、短网址服务，将长链接映射为短链接，更方便该路径在互联网，短信，海报等载体中传播，在运营和销售的场景下，还可以帮助工作人员统计业绩，用处非常大。</p><p>市面上比较常见的短链接有：新浪的t.cn、淘宝的tb.am、0x3.me（数据统计报表）。作为一个数据控，我更喜欢0x3.me这样的提供一整套数据报表的短网址服务，更为专业，短链接系统的价值也体现越大。</p><h2 id="原理">原理</h2><p>短链接的保存可以采用62进制法，在数据库中，使用 <code>十进制</code> 的ID保存每一条长链接，例如：</p><table><thead><tr class="header"><th>ID(十进制)</th><th>URL</th><th>ID的62进制</th></tr></thead><tbody><tr class="odd"><td>1</td><td>https://baidu.com</td><td>000001</td></tr><tr class="even"><td>2</td><td>https://jd.com?a=1&amp;b=c</td><td>000002</td></tr><tr class="odd"><td>3</td><td>https://taobao.com/ccc/ddd/eee</td><td>000003</td></tr><tr class="even"><td>...</td><td>...</td><td>...</td></tr><tr class="odd"><td>9326778807</td><td>https://qq.com</td><td>abcdef</td></tr></tbody></table><p>我们将十进制的ID转换为62进制，即可得到一个短链接的Code。一个六位的Code由<code>0-9a-zA-Z</code>组成，总共的组合超过500亿条，显然可以满足大部分的短链接需求。</p><p>假设我们的短链接网址的域名是<code>x.com</code>，那么我们的短链接地址就是<code>x.com/abcdef</code>，我们写好后台程序，当请求进来时，我们从数据库中找到对应的长链接，使用301或者302跳转，将长链接提供给访问者，即可实现一个短链接跳转的功能。</p><h2 id="设计">设计</h2><p>基本的原理搞清楚了，我们开始设计短链接系统，想要设计一个高性能的短链接系统，首先要确定该系统的架构，这次我们选用了Java来开发后端，MySQL作存储，前端使用Vue来进行前后端分离。当前各大企业最流行的开发的结构。在日志收集和分析的模块，我们使用ELK架构，分析每一次访问的数据，包括IP，访问地域，访问操作系统等信息，存储在ElasticSearch中，在数据和图标展示模块，我们使用ES的聚合函数进行数据聚合，并使用Echarts进行展示。</p><p><strong>架构图</strong></p><p>根据上述设计，我们可以画出一个短链接系统的架构图：</p><p><img src="/2019/01/03/如何设计一个短链接网站/系统架构设计.png"></p><p>架构设计好后我们开始进行编码</p><h2 id="表结构设计">表结构设计</h2><p>首先设计短链接存储的表，这是本系统的核心表，存储着所有的短链接：</p><table><thead><tr class="header"><th>名称</th><th>类型</th><th>非空</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>id</td><td>bigint(20) unsigned</td><td>True</td><td></td><td>自增主键</td></tr><tr class="even"><td>long_url</td><td>text</td><td>True</td><td></td><td>长链接</td></tr><tr class="odd"><td>code</td><td>varchar(10)</td><td>True</td><td></td><td>短链接码（ID的62进制）</td></tr><tr class="even"><td>description</td><td>varchar(255)</td><td>False</td><td></td><td>短链接的说明（可选）</td></tr><tr class="odd"><td>created_time</td><td>timestamp</td><td>False</td><td>CURRENT_TIMESTAMP</td><td>创建时间</td></tr><tr class="even"><td>created_by</td><td>varchar(32)</td><td>False</td><td></td><td>创建人</td></tr><tr class="odd"><td>del_flag</td><td>tinyint(1) unsigned</td><td>True</td><td>0</td><td>是否被删除</td></tr><tr class="even"><td>view</td><td>int(10)</td><td>False</td><td>0</td><td>访问次数</td></tr><tr class="odd"><td>expired_at</td><td>timestamp</td><td>False</td><td>0</td><td>过期的时间（可以设置短链接过期）</td></tr><tr class="even"><td>max_view</td><td>int(10)</td><td>False</td><td>0</td><td>最大访问量（可以设置短链接最大的访问量）</td></tr><tr class="odd"><td>password</td><td>varchar(32)</td><td>False</td><td>null</td><td>可以设置密码（设置后访问需要使用密码）</td></tr></tbody></table><p>在访问日志方面，我们设计的存储方式是存储至ES，使用Logstash进行日志采集：</p><p><img src="/2019/01/03/如何设计一个短链接网站/el.png"></p><p>一个典型的JSON格式访问日志应该是这样的</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"id"</span>: <span class="number">1469872</span>,</span><br><span class="line"><span class="attr">"reqIp"</span>: <span class="string">"61.129.6.159"</span>,</span><br><span class="line"><span class="attr">"reqTime"</span>: <span class="string">"2019-01-03T15:16:30.672+0800"</span>,</span><br><span class="line"><span class="attr">"reqIsp"</span>: <span class="string">"电信"</span>,</span><br><span class="line"><span class="attr">"reqCity"</span>: <span class="string">"上海市"</span>,</span><br><span class="line"><span class="attr">"reqRegion"</span>: <span class="string">"上海"</span>,</span><br><span class="line"><span class="attr">"reqCountry"</span>: <span class="string">"中国"</span>,</span><br><span class="line"><span class="attr">"reqShortCode"</span>: <span class="string">"a0009B"</span>,</span><br><span class="line"><span class="attr">"reqShortId"</span>: <span class="number">9161328915</span>,</span><br><span class="line"><span class="attr">"reqStatus"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"reqMessage"</span>: <span class="string">"访问正常"</span>,</span><br><span class="line"><span class="attr">"reqOs"</span>: <span class="string">"Windows 7"</span>,</span><br><span class="line"><span class="attr">"reqBrowser"</span>: <span class="string">"Chrome内核"</span>,</span><br><span class="line"><span class="attr">"reqDevice"</span>: <span class="string">"Windows"</span>,</span><br><span class="line"><span class="attr">"reqUa"</span>: <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"</span>,</span><br><span class="line"><span class="attr">"reqUrl"</span>: <span class="string">"http://localhost:8088/a0009B"</span>,</span><br><span class="line"><span class="attr">"reqParams"</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据IP计算出访问地域我们使用的是 <a href="https://github.com/lionsoul2014/ip2region" target="_blank" rel="noopener">ip2region</a> 组件，该组件的优势是免费且速度快，缺点是需要定时更新数据库。</p><h2 id="后端">后端</h2><p>后端我们使用目前最流行的Spring Boot + Mybatis来进行开发。主要涵盖的内容有这几块</p><ul><li>用户管理（注册、登录）</li><li>短链接的管理（生成、删除、查看）</li><li>短链接的查看（访问日志，数据统计）</li><li>短链接的统计（每日访问统计，每次访问的数据分析）</li></ul><p><strong>响应短链接跳转</strong></p><p>当短链接请求过来的时候，我们需要处理短链接跳转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/&#123;shortUrlCode&#125;"</span>)  <span class="comment">//响应类似 x.com/abcdef 这样的请求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">redirect</span><span class="params">(@PathVariable(required = <span class="keyword">false</span>)</span> String shortUrlCode, HttpServletRequest request, HttpServletResponse response) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(shortUrlCode) || shortUrlCode.length() &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;  <span class="comment">// 如果没有传Code，则跳转到首页去</span></span><br><span class="line">    &#125;</span><br><span class="line">    String ipAddress = NetworkUtil.getIpAddress(request);  <span class="comment">//获得IP地址</span></span><br><span class="line">    ServiceResult serviceResult = shortUrlService.getLongUrlByShortUrl(shortUrlCode); <span class="comment">//获得长链接信息</span></span><br><span class="line">    AccessRecordEvent accessRecordEvent = <span class="keyword">new</span> AccessRecordEvent();</span><br><span class="line">    accessRecordEvent.setReqShortCode(shortUrlCode)</span><br><span class="line">        .setServiceResult(serviceResult)</span><br><span class="line">        .setIpAddress(ipAddress);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != request.getHeader(<span class="string">"User-Agent"</span>)) &#123;</span><br><span class="line">        accessRecordEvent.setUserAgent(request.getHeader(<span class="string">"User-Agent"</span>)); <span class="comment">//得到User-Agent以便分析浏览器、操作系统信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    Dew.cluster.mq.request(MQTopic.ACCESS_RECORD, $.json.toJsonString(accessRecordEvent));  <span class="comment">//发送MQ请求，异步记录访问日志</span></span><br><span class="line">    <span class="keyword">if</span> (serviceResult.getCode() == <span class="number">200</span>) &#123;</span><br><span class="line">        Map data = (Map) serviceResult.getData();</span><br><span class="line">        response.sendRedirect((String) data.get(<span class="string">"longUrl"</span>)); <span class="comment">// redirect 至长链接</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果找不到指定短链接Code，则跳转到404页面。</span></span><br><span class="line">        response.sendRedirect(<span class="string">"/404.html"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要实现了两件事：</p><ol type="1"><li>记录访问日志</li><li>跳转至长链接</li></ol><p>这也是短链接跳转的核心方法，需要对这个接口进行压力测试。</p><blockquote><p>为了方便说明，简化了 最大访问量检测，过期检测以及密码检测</p></blockquote><h2 id="前端">前端</h2><p>前端我们使用 Vue+iView 进行开发，使用这个组合可以快速且优雅地开发出美观的前端应用，前端主要功能：</p><ul><li>首页（创建短连接、用户登录、系统介绍）</li><li>短链接管理（删除、查看短链接）</li><li>访问日志（查看短链接访问日志）</li><li>图表控制台（使用Echarts对数据进行可视化展示）</li></ul><p><strong>效果</strong></p><p><img src="/2019/01/03/如何设计一个短链接网站/1.png"></p><p><img src="/2019/01/03/如何设计一个短链接网站/2.png"></p><p><img src="/2019/01/03/如何设计一个短链接网站/4.png"></p><h2 id="总结">总结</h2><p>在开发好一个短链接系统后，还需要进行大量的测试，包括单元测试，黑盒白盒，压力测试。短链接系统虽然从原理上讲并不算复杂，但是要设计和开发好一个好用且功能齐全的短链接，也是需要费一番功夫的。</p><p>同时欢迎大家访问我司短链接系统： <a href="http://r2a.cn" target="_blank" rel="noopener">r2a.cn</a></p><p>今天的文章就到这里，我们下次再见。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="思路" scheme="https://lzx2005.github.io/categories/%E6%80%9D%E8%B7%AF/"/>
    
    
      <category term="Java" scheme="https://lzx2005.github.io/tags/Java/"/>
    
      <category term="设计" scheme="https://lzx2005.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="思路" scheme="https://lzx2005.github.io/tags/%E6%80%9D%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>使用parallelStream并行处理集合</title>
    <link href="https://lzx2005.github.io/2018/12/27/%E4%BD%BF%E7%94%A8parallelStream%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E9%9B%86%E5%90%88/"/>
    <id>https://lzx2005.github.io/2018/12/27/使用parallelStream并行处理集合/</id>
    <published>2018-12-27T05:39:22.000Z</published>
    <updated>2019-09-10T07:28:52.434Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在公司的风控系统搬砖，写代码时，其中的某一个步骤是将一个大的Map（内有上万条Key，Value值）遍历一遍，逐一分析每一个Key，Value值，并进行因子解析，以便建立用户画像。其中因子解析的步骤，可能会很长，涉及到数值计算，数据库查询或者接口调用，处理速度从1ms-100ms不等，当总数据量超过一万条时，对整个系统的性能损耗非常大。</p><h2 id="使用parallelstream">使用parallelStream</h2><p>我接手到的代码是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理数据，耗时1ms-100ms或更高</span></span><br><span class="line">    System.out.println(key +<span class="string">":"</span>+ value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>既然用到了Stream来处理，于是我便使用了parallelStream来实现集合的<code>并行处理</code>，只需要对Stream调用链加上<code>parallelStream()</code>方法即可打开：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().parallelStream().forEach(entry -&gt; &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    System.out.println(entry.getKey() +<span class="string">":"</span>+ entry.getValue());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>该方法即可打开Java并行处理集合的功能，让我们来写方法验证该方法是否可以真的提高处理速度。 首先我们构建一个测试数据，一个只有大小为10的HashMap：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        map.put(<span class="string">"k"</span>+i, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写两个方法（不用并行与使用并行），都输出值，并计算耗时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">    sleep(<span class="number">100</span>); <span class="comment">// 模拟处理时间</span></span><br><span class="line">    System.out.print(value + <span class="string">","</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> mid = System.currentTimeMillis();</span><br><span class="line">System.out.println(mid - start + <span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">map.entrySet().parallelStream().forEach(entry -&gt; &#123;</span><br><span class="line">    sleep(<span class="number">100</span>); <span class="comment">// 模拟处理时间</span></span><br><span class="line">    System.out.print(entry.getValue() + <span class="string">","</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(end - mid + <span class="string">"ms"</span>);</span><br></pre></td></tr></table></figure><p>执行后，得到的结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">1129</span>ms</span><br><span class="line"><span class="number">9</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">321</span>ms</span><br></pre></td></tr></table></figure><p>从以上的输出可以得出的基本结论有：</p><ol type="1"><li>使用parallelStream的代码确实是并行运行了，因为输出不是正序的</li><li>使用parallelStream确实可以在某种程度提高集合处理速度</li></ol><h2 id="线程安全">线程安全</h2><p>显而易见，parallelStream是非线程安全的，举个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">10000</span>).forEach(list1::add);</span><br><span class="line"></span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">10000</span>).parallel().forEach(list2::add);</span><br><span class="line"></span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">10000</span>).forEach(i -&gt; &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list3.add(i);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"串行执行的大小："</span> + list1.size());</span><br><span class="line">    System.out.println(<span class="string">"并行执行的大小："</span> + list2.size());</span><br><span class="line">    System.out.println(<span class="string">"加锁并行执行的大小："</span> + list3.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">串行执行的大小：<span class="number">10000</span></span><br><span class="line">并行执行的大小：<span class="number">9595</span></span><br><span class="line">加锁并行执行的大小：<span class="number">10000</span></span><br></pre></td></tr></table></figure><p>所以，我们在使用parallelStream时，需要注意线程安全的问题，该加锁的就加锁，外部调用的ArrayList，HashMap等也必须使用和其对等的线程安全类，例如：ConcurrentHashMap等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java" scheme="https://lzx2005.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://lzx2005.github.io/tags/Java/"/>
    
      <category term="Stream" scheme="https://lzx2005.github.io/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>《深度学习入门：基于Python的理论与实现》读书笔记（二）感知机</title>
    <link href="https://lzx2005.github.io/2018/12/04/deep-learning-read-perceptron/"/>
    <id>https://lzx2005.github.io/2018/12/04/deep-learning-read-perceptron/</id>
    <published>2018-12-04T08:42:03.000Z</published>
    <updated>2019-09-10T07:28:52.432Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天学习了第二章：感知机。</p><h2 id="感知机是什么">感知机是什么</h2><p>感知机(perceptron)这一算法是由美国学者 Frank Rosenblatt 在 1957 年提出来的。感知机接收多个输入信号，输出一个信号。这里所说的“信号”可以想 象成电流或河流那样具备“流动性”的东西。像电流流过导线，向前方输送 电子一样，感知机的信号也会形成流，向前方输送信息。但是，和实际的电 流不同的是，感知机的信号只有“流 / 不流”(1/0)两种取值。在本书中，0 对应“不传递信号”，1 对应“传递信号”。</p><p>x1、x2 是输入信号， y是输出信号，w1、w2 是权重(w是weight的首字母)。图中的○称为“神 经元”或者“节点”。输入信号被送往神经元时，会被分别乘以固定的权重(w1x1、w2x2)。神经元会计算传送过来的信号的总和，只有当这个总和超过 了某个界限值时，才会输出1。这也称为“神经元被激活”。这里将这个界 限值称为阈值，用符号 θ 表示。</p><p><img src="/2018/12/04/deep-learning-read-perceptron/image-20181204164645329.png"></p><p>把上述内容用数学式来表示，就是式(2.1)：</p><p><span class="math display">\[y=\begin{cases}0 &amp; (w_1x_1+w_2x_2) \leqslant \theta\\1 &amp; (w_1x_1+w_2x_2) &gt; \theta\end{cases}\tag{2.1}\label{l2.1}\]</span></p><p>感知机的多个输入信号都有各自固有的权重，这些权重发挥着控制各个 信号的重要性的作用。也就是说，权重越大，对应该权重的信号的重要性就越高。</p><h2 id="感知机实现与门电路">感知机实现与门电路</h2><h3 id="与门">与门</h3><h4 id="方案">方案</h4><p><img src="/2018/12/04/deep-learning-read-perceptron/image-20181204173702633.png"></p><p>选择方法有无数多个。比如，当(w1, w2, θ) = (0.5, 0.5, 0.7) 时，可 以 满 足 图 2-2 的 条 件。此 外，当 (w1, w2, θ)为 (0.5, 0.5, 0.8) 或者 (1.0, 1.0, 1.0) 时，同样也满足与门的条件。设定这样的参数后，仅当 x1 和 x2 同时为 1 时，信号的加权总和才会超过给定的阈值 θ。</p><h4 id="实现">实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AND</span><span class="params">(x1, x2)</span>:</span></span><br><span class="line">    w1, w2, theta = <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.7</span> </span><br><span class="line">    tmp = x1*w1 + x2*w2</span><br><span class="line">    <span class="keyword">if</span> tmp &lt;= theta:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> tmp &gt; theta:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AND(<span class="number">0</span>, <span class="number">0</span>) <span class="comment"># 输出0 </span></span><br><span class="line">AND(<span class="number">1</span>, <span class="number">0</span>) <span class="comment"># 输出0 </span></span><br><span class="line">AND(<span class="number">0</span>, <span class="number">1</span>) <span class="comment"># 输出0 </span></span><br><span class="line">AND(<span class="number">1</span>, <span class="number">1</span>) <span class="comment"># 输出1</span></span><br></pre></td></tr></table></figure><h2 id="导入权重和偏置">导入权重和偏置</h2><p>式(2.1)的θ换成−b，于是就可以用式(2.2)来表示感知机的行为：</p><p><span class="math display">\[y=\begin{cases}0 &amp; (b+w_1x_1+w_2x_2) \leqslant 0\\1 &amp; (b+w_1x_1+w_2x_2) &gt; 0\end{cases}\tag{2.2}\label{l2.2}\]</span></p><p>此处，b 称为偏置，w1 和 w2 称为权重。如式(2.2)所示，感知机会计算输入信号和权重的乘积，然后加上偏置，如果这个值大于 0 则输出 1，否则输出 0。下面，我们使用 NumPy，按式(2.2)的方式实现感知机：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AND</span><span class="params">(x1, x2)</span>:</span></span><br><span class="line">    x = np.array([x1, x2]) <span class="comment"># 输入信号</span></span><br><span class="line">    w = np.array([<span class="number">0.5</span>, <span class="number">0.5</span>]) <span class="comment"># 权重</span></span><br><span class="line">    b = <span class="number">-0.7</span> <span class="comment"># 偏置</span></span><br><span class="line">    tmp = np.sum(w*x) + b <span class="comment"># 计算</span></span><br><span class="line">    <span class="keyword">if</span> tmp &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这里把 −θ 命名为偏置 b，但是请注意，偏置和权重 w1、w2 的作用是不一样的。具体地说，w1 和 w2 是控制输入信号的重要性的参数，而偏置是调整神经元被激活的容易程度(输出信号为 1 的程度)的参数。比如，若 b 为−0.1，则只要输入信号的加权总和超过 0.1，神经元就会被激活。但是如果 b为 −20.0，则输入信号的加权总和必须超过 20.0，神经元才会被激活。像这样，偏置的值决定了神经元被激活的容易程度。另外，这里我们将 w1 和 w2 称为权重，将 b 称为偏置，但是根据上下文，有时也会将 b、w1、w2 这些参数统称为权重。</p><h2 id="实现与非门和或门">实现与非门和或门</h2><h3 id="与非门">与非门</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NAND</span><span class="params">(x1, x2)</span>:</span></span><br><span class="line">    x = np.array([x1, x2])</span><br><span class="line">    w = np.array([<span class="number">-0.5</span>, <span class="number">-0.5</span>]) <span class="comment"># 仅权重和偏置与AND不同! </span></span><br><span class="line">    b = <span class="number">0.7</span></span><br><span class="line">    tmp = np.sum(w*x) + b</span><br><span class="line">    <span class="keyword">if</span> tmp &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="或门">或门</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OR</span><span class="params">(X1, X2)</span>:</span></span><br><span class="line">    x = np.array([x1, x2])</span><br><span class="line">    w = np.array([<span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line">    b = <span class="number">-0.2</span></span><br><span class="line">    tmp = np.sum(w*x) + b</span><br><span class="line">    <span class="keyword">if</span> tmp &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="感知机的局限性">感知机的局限性</h2><p>因为感知机是线性空间，所以单层感知机无法实现<code>异或门(XOR gate)</code>。</p><h3 id="线性和非线性">线性和非线性</h3><p>由图 2-8 这样的曲线分割而成的空间称为<code>非线性空间</code>，由直线分割而成的空间称为<code>线性空间</code>。</p><p><img src="/2018/12/04/deep-learning-read-perceptron/image-20181204175508265.png"></p><h2 id="多层感知机">多层感知机</h2><p>我们可以使用如下结构来实现异或门：</p><p><img src="/2018/12/04/deep-learning-read-perceptron/image-20181204175602636.png"></p><p><img src="/2018/12/04/deep-learning-read-perceptron/image-20181204175644926.png"></p><p>异或门是一种多层结构的神经网络。这里，将最左边的 一列称为第 0 层，中间的一列称为第 1 层，最右边的一列称为第 2 层。图所示的感知机与前面介绍的与门、或门的感知机(图 2-1)形状不同。实际上，与门、或门是单层感知机，而异或门是 2 层感知机。叠加了多层的感知机也称为多层感知机(multi-layered perceptron)。</p><p>这种 2 层感知机的运行过程可以比作流水线的组装作业。第 1 段(第 1 层) 的工人对传送过来的零件进行加工，完成后再传送给第 2 段(第 2 层)的工人。 第 2 层的工人对第 1 层的工人传过来的零件进行加工，完成这个零件后出货 (输出)。 像这样，在异或门的感知机中，工人之间不断进行零件的传送。通过这样的结构 ( 2层结构 )， 感知机得以实现异或门 。 这可以解释为 “ 单层感知机无法表示的东西，通过增加一层就可以解决”。也就是说，通过叠加层(加深 层)，感知机能进行更加灵活的表示。</p><h2 id="小结">小结</h2><ul><li><p>感知机是具有输入和输出的算法。给定一个输入后，将输出一个既定的值。</p></li><li><p>感知机将权重和偏置设定为参数。</p></li><li><p>使用感知机可以表示与门和或门等逻辑电路。</p></li><li><p>异或门无法通过单层感知机来表示。</p></li><li><p>使用2层感知机可以表示异或门。</p></li><li><p>单层感知机只能表示线性空间，而多层感知机可以表示非线性空间。</p></li><li><p>多层感知机(在理论上)可以表示计算机。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://lzx2005.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="https://lzx2005.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://lzx2005.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="https://lzx2005.github.io/tags/Python/"/>
    
      <category term="读后感" scheme="https://lzx2005.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
      <category term="读书笔记" scheme="https://lzx2005.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《深度学习入门：基于Python的理论与实现》读书笔记（一）</title>
    <link href="https://lzx2005.github.io/2018/12/03/deap-learning-read-python-basic/"/>
    <id>https://lzx2005.github.io/2018/12/03/deap-learning-read-python-basic/</id>
    <published>2018-12-03T14:52:23.000Z</published>
    <updated>2019-09-10T07:28:52.431Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天阅读的是《深度学习入门：基于Python的理论与实现》第0-19页部分，主要介绍了Python的知识和相应的库的使用。</p><h2 id="python基础知识">Python基础知识</h2><h3 id="python">Python</h3><p>Python 是一个简单、易读、易记的编程语言，而且是开源的，可以免费地自由使用。Python 可以用类似英语的语法编写程序，编译起来也不费力，因此我们可以很轻松地使用 Python。</p><h3 id="版本的区别">版本的区别</h3><p>Python有Python 2.x和Python 3.x两个版本。因此，在安装 Python 时，需要慎重选择安装 Python 的哪个版本。这是因为两个版本之间没有向后兼容性。</p><h3 id="numpy和matplotlib库">NumPy和Matplotlib库</h3><p>NumPy 是用于数值计算的库，提供了很多高级的数学算法和便利的数组(矩阵)操作方法。本书中将使用这些便利的方法来有效地促进深度学习的实现。</p><p>Matplotlib 是用来画图的库。使用 Matplotlib 能将实验结果可视化，并在视觉上确认深度学习运行期间的数据。</p><h2 id="python的使用">Python的使用</h2><h3 id="查看python版本">查看Python版本</h3><p>安装好Python3后，打开终端，输入<code>python3 --version</code>即可查询到当前安装的python版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; python3 --version</span><br><span class="line">Python 3.7.1</span><br></pre></td></tr></table></figure><p>在官网安装的Python2.7和Python3.7在终端访问的方式略有不同：</p><ul><li>Python2 : python --version</li><li>Python3 : python3 --version (Windows环境为py --version)</li></ul><h3 id="python-解释器">Python 解释器</h3><p>Python 解释器也被称为“对话模式”，用户能够以和 Python 对话的方式进行编程。比如，当用户询问“1 + 2 等于几?”的时候，Python 解释器会回答“3”，所谓对话模式，就是指这样的交互：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> python3</span></span><br><span class="line">Python 3.7.1 (v3.7.1:260ec2c36a, Oct 20 2018, 03:13:28)</span><br><span class="line">[Clang 6.0 (clang-600.0.57)] on darwin</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 1+2</span></span><br><span class="line">3</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="算数计算">算数计算</h3><p>*表示乘法，/表示除法，**表示乘方(3**2是3的2次方)。这部分跟大部分的编程语言类似，但是也使用了**这样的在Java中没见过的语法糖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 1+2</span></span><br><span class="line">3</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 1-2</span></span><br><span class="line">-1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 4*5</span></span><br><span class="line">20</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 7/5</span></span><br><span class="line">1.4</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 3**2</span></span><br><span class="line">9</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="数据类型">数据类型</h3><p>Python编程中有数据类型(data type)这一概念。数据类型表示数据的性质，有整数、小数、字符串等类型。Python 中的 type() 函数可以用来查看数据 类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">type</span>(10)</span></span><br><span class="line">&lt;class 'int'&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">type</span>(2.718)</span></span><br><span class="line">&lt;class 'float'&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">type</span>(<span class="string">'abc'</span>)</span></span><br><span class="line">&lt;class 'str'&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="变量">变量</h3><p>可以使用 x 或 y 等字母定义变量(variable)。此外，可以使用变量进行计算，也可以对变量赋值。 &gt; 注：python2.7的打印方式为 <code>print x</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; x=10</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(x)</span></span><br><span class="line">10</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>Python 是属于“动态类型语言”的编程语言，所谓动态，是指变量的类型是根据情况自动决定的。在上面的例子中，用户并没有明确指出“x 的类型是 int(整型)”，是 Python 根据 x 被初始化为 10，从而判断出 x 的类型为int 的。此外，我们也可以看到，整数和小数相乘的结果是小数(数据类型的自动转换)。</p><p>另外，“#”是注释的意思，它后面的文字会被 Python 忽略。</p><h3 id="列表">列表</h3><h4 id="创建和打印列表">创建和打印列表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">99</span>] <span class="comment"># 生成列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">99</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="切片访问">切片访问</h4><p>Python 的列表提供了切片 (slicing)这一便捷的标记法。使用切片不仅可以访问某个值，还可以访问列表的子列表(部分列表)。</p><p>进行列表的切片时，需要写成 a[0:2] 这样的形式。a[0:2] 用于取出从索引为 0 的元素到索引为 2 的元素的前一个元素之间的元素。另外，索引 −1 对应最后一个元素，−2 对应最后一个元素的前一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 获取索引为0到2(不包括2!)的元素 [1, 2]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:] <span class="comment"># 获取从索引为 1 的元素到最后一个元素 [2, 3, 4, 99]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">3</span>] <span class="comment"># 获取从第一个元素到索引为 3(不包括 3 !)的元素</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">-1</span>] <span class="comment"># 获取从第一个元素到最后一个元素的前一个元素之间的元素 [1, 2, 3, 4]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">-2</span>] <span class="comment"># 获取从第一个元素到最后一个元素的前二个元素之间的元素 [1, 2, 3]</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="字典">字典</h3><p>Python字典类似Java中的Map结构，也就是Json格式中的Key:value结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>me = &#123;<span class="string">'height'</span>:<span class="number">180</span>&#125; <span class="comment"># 生成字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>me[<span class="string">'height'</span>] <span class="comment"># 访问元素 180</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>me[<span class="string">'weight'</span>] = <span class="number">70</span> <span class="comment"># 添加新元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(me)</span><br><span class="line">&#123;<span class="string">'height'</span>: <span class="number">180</span>, <span class="string">'weight'</span>: <span class="number">70</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="布尔型">布尔型</h3><p>布尔型则比较好理解，类似Java中的Boolean类型，但是Python中的判断更加像平时说话的方式，用<code>and</code>替代<code>&amp;&amp;</code>，用<code>or</code>替代<code>||</code>，使代码可读性大大加强：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hungry = <span class="keyword">True</span> <span class="comment"># 饿了?</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sleepy = <span class="keyword">False</span> <span class="comment"># 困了?</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(hungry)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">bool</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">not</span> <span class="title">hungry</span></span></span><br><span class="line"><span class="class"><span class="title">False</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">hungry</span> <span class="title">and</span> <span class="title">sleepy</span> # 饿并且困 <span class="title">False</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">hungry</span> <span class="title">or</span> <span class="title">sleepy</span> # 饿或者困 <span class="title">True</span></span></span><br></pre></td></tr></table></figure><h3 id="if-语句">If 语句</h3><p>Python中的空白字符具有重要的意义。上面的if语句中，if hungry:下面的语句开头有4个空白字符。它是缩进的意思，表示当前面的条件(if hungry)成立时，此处的代码会被执行。这个缩进也可以用 tab 表示，Python 中推荐使用空白字符。</p><p>也就是说，Python使用缩进代替了Java中的<code>{</code>、<code>}</code>来对代码进行分块。同时强烈建议使用四空格代替<code>\t</code>来进行缩进，这样在Win平台和Linux平台显示的缩进就会相同，而不会出现格式乱掉的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hungry = <span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> hungry:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"I'm hungry"</span>)</span><br><span class="line">...</span><br><span class="line">I<span class="string">'m hungry</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="for-语句">For 语句</h3><p>for...in...更加符合平时的阅读习惯：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="函数">函数</h3><p>可以将一连串的处理定义成函数(function)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"hello world"</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hello()</span><br><span class="line">hello world</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>由于是动态类型语言，所以不需要指定返回值类型。</p><h3 id="退出对话模式">退出对话模式</h3><p>关闭Python解释器时，Linux或Mac OS X的情况下输入Ctrl-D(按住Ctrl，再按 D 键);Windows 的情况下输入 Ctrl-Z，然后按 Enter 键。当然我更喜欢在对话框中输入<code>exit()</code>来退出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>exit()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h2 id="python-脚本文件">Python 脚本文件</h2><p>可以将Python 程序保存为文件，然后(集中地)运行这个文件，文件后续名为<code>.py</code>。 使用方式为在终端中输入 <code>python3 filename.py</code> 即可执行Python脚本文件，非常方便。</p><h2 id="类">类</h2><p>Python 中使用 class 关键字来定义类，类要遵循下述格式(模板)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, 参数, ...)</span>:</span> <span class="comment"># 构造函数</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> 方法名1<span class="params">(self, 参数, ...)</span>:</span> <span class="comment"># 方法1</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> 方法名2<span class="params">(self, 参数, ...)</span>:</span> <span class="comment"># 方法2</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>这里有一个特殊的 <strong>init</strong> 方法，这是进行初始化的方法，也称为构造函数(constructor), 只在生成类的实例时被调用一次。此外，在方法的第一个参数中明确地写入表示自身(自身的实例)的 self 是 Python 的一个特点。</p><h2 id="numpy">NumPy</h2><p>在深度学习的实现中，经常出现数组和矩阵的计算。NumPy 的数组类 (numpy.array)中提供了很多便捷的方法</p><h3 id="使用numpy">使用Numpy</h3><h4 id="基本运算">基本运算</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import numpy as np</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; x = np.array([1.0, 2.0, 3.0]) &gt;&gt;&gt; <span class="built_in">print</span>(x)</span></span><br><span class="line">[ 1. 2. 3.]</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">type</span>(x)</span></span><br><span class="line">&lt;class 'numpy.ndarray'&gt;</span><br></pre></td></tr></table></figure><blockquote><p>如果出现<code>ModuleNotFoundError: No module named 'numpy'</code>则需要使用pip安装Numpy</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> pip3 install numpy</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>安装完成后即可使用</p></blockquote><p>NumPy 数组的算术运算：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; y = np.array([2.0, 3.0, 4.0])</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; x+y</span></span><br><span class="line">array([3., 5., 7.])</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>如果元素个数不同，程序就会报错，所以元素个数保持一致非常重要。“对应元素的”的英文是 element-wise，比如“对应元素的乘法”就是element-wise product。</p><p>生成多维数组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; A = np.array([[1, 2], [3, 4]])</span></span><br></pre></td></tr></table></figure><p>矩阵运算</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; B = np.array([[3, 0],[0, 6]])</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; A + B</span></span><br><span class="line">array([[ 4, 2],</span><br><span class="line">  [ 3, 10]])</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; A * 10</span></span><br><span class="line">array([[ 10, 20],</span><br><span class="line">  [ 30, 40]])</span><br></pre></td></tr></table></figure><h4 id="广播">广播</h4><p>NumPy 中，形状不同的数组之间也可以进行运算。之前的例子中，在2×2 的矩阵 A 和标量 10 之间进行了乘法运算。在这个过程中，如图 1-1 所示，标量 10 被扩展成了 2 × 2 的形状，然后再与矩阵 A 进行乘法运算。这个巧妙的功能称为广播(broadcast)。</p><p><img src="/2018/12/03/deap-learning-read-python-basic/image-20181204000528179.png"></p><p><img src="/2018/12/03/deap-learning-read-python-basic/image-20181204000707627.png"></p><h4 id="访问元素">访问元素</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; X[0][1] <span class="comment"># (0,1)的元素</span></span></span><br><span class="line">或者</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="keyword">for</span> row <span class="keyword">in</span> X:</span></span><br><span class="line">...print(row)</span><br></pre></td></tr></table></figure><h2 id="matplotlib">Matplotlib</h2><p>在深度学习的实验中，图形的绘制和数据的可视化非常重要。Matplotlib 是用于绘制图形的库，使用 Matplotlib 可以轻松地绘制图形和实现数据的可视化。</p><h3 id="绘制简单图形">绘制简单图形</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 生成数据</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">6</span>, <span class="number">0.1</span>) <span class="comment"># 以0.1为单位，生成0到6的数据</span></span><br><span class="line">y = np.sin(x)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>这里使用NumPy的arange方法生成了[0, 0.1, 0.2, ..., 5.8, 5.9]的数据，将其设为 x。对 x 的各个元素，应用 NumPy 的 sin 函数 np.sin()，将 x、y 的数据传给 plt.plot 方法，然后绘制图形。最后，通过 plt.show() 显示图形。运行上述代码后，就会显示图 1-3 所示的图形：</p><p><img src="/2018/12/03/deap-learning-read-python-basic/image-20181204001039527.png"></p><h3 id="显示图像">显示图像</h3><p>pyplot中还提供了用于显示图像的方法imshow()。另外，可以使用matplotlib.image 模块的 imread() 方法读入图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.image <span class="keyword">import</span> imread</span><br><span class="line"></span><br><span class="line">img = imread(<span class="string">'lena.png'</span>) <span class="comment"># 读入图像(设定合适的路径!)</span></span><br><span class="line">plt.imshow(img)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://lzx2005.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="https://lzx2005.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://lzx2005.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="https://lzx2005.github.io/tags/Python/"/>
    
      <category term="读后感" scheme="https://lzx2005.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
      <category term="读书笔记" scheme="https://lzx2005.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用MongoDB的位置索引实现“附近的人”的计算</title>
    <link href="https://lzx2005.github.io/2017/04/28/mongo-point/"/>
    <id>https://lzx2005.github.io/2017/04/28/mongo-point/</id>
    <published>2017-04-27T23:57:41.000Z</published>
    <updated>2019-09-10T07:28:52.434Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="使用mongodb的位置索引实现附近的人的计算">使用MongoDB的位置索引实现“附近的人”的计算</h3><p>最近一直在忙工作和毕设，没什么时间写博客，真的非常不好意思，在写毕设的时候，有一个需求，就是找到地图上附近的点，我使用的是MongoDB存储我的信息，正好Mongo也有位置索引，也可以进行位置搜索，而且使用起来非常方便，这边记录一下。</p><ul><li>语言：Java8</li><li>框架：Spring MVC、Spring、Mybatis</li><li>数据库：MongoDB 3.4.2</li></ul><h4 id="数据保存">数据保存</h4><p>你需要将坐标数据以特定的格式保存到MongoDB，我的数据源如下所示： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"restaurantId"</span> : <span class="string">"fd433baf3a7e4722bdd2c7a9c1a0f7c0"</span>,</span><br><span class="line">    <span class="attr">"restaurantName"</span> : <span class="string">"XX餐厅"</span>,</span><br><span class="line">    <span class="attr">"belong"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"createTime"</span> : <span class="string">"2017-04-26T09:24:43.266Z"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>想要给他加上一个位置信息、<a href="https://docs.mongodb.com/manual/core/2d/" target="_blank" rel="noopener">官方文档</a>上是这样写的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loc : [ &lt;longitude&gt; , &lt;latitude&gt; ]</span><br><span class="line">和</span><br><span class="line">loc : &#123; lng : &lt;longitude&gt; , lat : &lt;latitude&gt; &#125;</span><br></pre></td></tr></table></figure><p>用这样两种方式都是可以的，记住，一定是lng在前，lat在后，之前写的时候就是因为顺序写反了，导致我一直算不出附近的点，非常气。 于是我的数据源就变成了如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"restaurantId"</span> : <span class="string">"fd433baf3a7e4722bdd2c7a9c1a0f7c0"</span>,</span><br><span class="line">    <span class="attr">"restaurantName"</span> : <span class="string">"XX餐厅"</span>,</span><br><span class="line">    <span class="attr">"position"</span> : [</span><br><span class="line">        <span class="number">120.576861</span>,</span><br><span class="line">        <span class="number">30.000107</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"belong"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"createTime"</span> : <span class="string">"2017-04-26T09:24:43.266Z"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在MongoDB的客户端选择上，Spring Data的MongoTemplate非常方便，可以使用它对Mongo做一系列操作， 将数据源插入MongoDB以及对位置信息做索引的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入数据，我使用了Restaurant这个类作为Entity，其实什么数据都可以，关键就是要有正确格式的坐标数据</span></span><br><span class="line">mongoTemplate.insert(restaurant,collectionName);</span><br><span class="line"><span class="comment">//定义某个key为位置索引，索引格式为GEO_2D</span></span><br><span class="line">GeospatialIndex position = <span class="keyword">new</span> GeospatialIndex(<span class="string">"position"</span>);</span><br><span class="line">position.typed(GeoSpatialIndexType.GEO_2D);</span><br><span class="line"><span class="comment">//索引操作，给position这个key添加位置索引</span></span><br><span class="line">mongoTemplate.indexOps(collectionName).ensureIndex(position);</span><br></pre></td></tr></table></figure><p>这样您保存的数据就已经做好了索引，我们可以多添加一些点。</p><h4 id="数据查询">数据查询</h4><p>假设你有一个APP，你获取到了你当前的坐标，想要获取左边周围固定范围的点的集合，这时候可以使用MongoDB来做，因为在上面我们已经对position做了索引，所以可以使用mongoTemplate的NearQuery类进行附近的点的查询，查询的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到当前用户的坐标</span></span><br><span class="line"><span class="keyword">double</span> lng = <span class="number">120.576861</span>;</span><br><span class="line"><span class="keyword">double</span> lat = <span class="number">30.000107</span>;</span><br><span class="line"><span class="comment">//定义范围，在这个范围内的点都会被返回</span></span><br><span class="line"><span class="keyword">double</span> length = <span class="number">1000.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NearQuery专门为位置查询而生，Metrics类储存了单位的数据，让您可以设置不同的单位，这里我们设置为KILOMETERS(千米)</span></span><br><span class="line">NearQuery nearQuery = NearQuery.near(lng, lat, Metrics.KILOMETERS).maxDistance(length);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询成功后则返回GeoResults&lt;T&gt;，该类专门存储位置信息和Entity信息，包括距离等有用的信息。</span></span><br><span class="line">GeoResults&lt;Restaurant&gt; geoResults = mongoTemplate.geoNear(nearQuery, Restaurant.class, collectionName);</span><br></pre></td></tr></table></figure><p>让我们来看一下GeoResults内部的格式是怎么样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"averageDistance"</span>: &#123;</span><br><span class="line">        <span class="attr">"metric"</span>: <span class="string">"KILOMETERS"</span>,</span><br><span class="line">        <span class="attr">"normalizedValue"</span>: <span class="number">0.003964060840443525</span>,</span><br><span class="line">        <span class="attr">"unit"</span>: <span class="string">"km"</span>,</span><br><span class="line">        <span class="attr">"value"</span>: <span class="number">25.28332311668394</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"content"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"content"</span>: &#123;</span><br><span class="line">                <span class="attr">"belong"</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="attr">"createTime"</span>: <span class="number">1493198674010</span>,</span><br><span class="line">                <span class="attr">"position"</span>: [</span><br><span class="line">                    <span class="number">120.152171</span>,</span><br><span class="line">                    <span class="number">30.266635</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">"restaurantId"</span>: <span class="string">"eea5e08be3dc4341b66ec0fc27b9a085"</span>,</span><br><span class="line">                <span class="attr">"restaurantName"</span>: <span class="string">"A"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"distance"</span>: &#123;</span><br><span class="line">                <span class="attr">"metric"</span>: <span class="string">"KILOMETERS"</span>,</span><br><span class="line">                <span class="attr">"normalizedValue"</span>: <span class="number">0.000014026592741484346</span>,</span><br><span class="line">                <span class="attr">"unit"</span>: <span class="string">"km"</span>,</span><br><span class="line">                <span class="attr">"value"</span>: <span class="number">0.08946353014839274</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"content"</span>: &#123;</span><br><span class="line">                <span class="attr">"belong"</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="attr">"createTime"</span>: <span class="number">1493198683266</span>,</span><br><span class="line">                <span class="attr">"position"</span>: [</span><br><span class="line">                    <span class="number">120.576861</span>,</span><br><span class="line">                    <span class="number">30.000107</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">"restaurantId"</span>: <span class="string">"fd433baf3a7e4722bdd2c7a9c1a0f7c0"</span>,</span><br><span class="line">                <span class="attr">"restaurantName"</span>: <span class="string">"B"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"distance"</span>: &#123;</span><br><span class="line">                <span class="attr">"metric"</span>: <span class="string">"KILOMETERS"</span>,</span><br><span class="line">                <span class="attr">"normalizedValue"</span>: <span class="number">0.007914095088145565</span>,</span><br><span class="line">                <span class="attr">"unit"</span>: <span class="string">"km"</span>,</span><br><span class="line">                <span class="attr">"value"</span>: <span class="number">50.47718270321948</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现MongoTemplate为我们封装了很多有用的信息，包括averageDistance平均距离都有。这样我们就可以把附近的点的信息找到啦，是不是非常方便？</p><h3 id="反馈与建议">反馈与建议</h3><ul><li>微博：<span class="citation" data-cites="lzx2005">[@lzx2005]</span>(http://weibo.com/u/2557929062)</li><li>邮箱：<a href="mailto:crow2005@vip.qq.com" class="email" target="_blank" rel="noopener">crow2005@vip.qq.com</a> ​</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="MongoDB" scheme="https://lzx2005.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://lzx2005.github.io/tags/MongoDB/"/>
    
      <category term="LBS" scheme="https://lzx2005.github.io/tags/LBS/"/>
    
  </entry>
  
</feed>
